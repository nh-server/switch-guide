import{_ as i,c as e,o as a,ae as t}from"./chunks/framework.DBofN92C.js";const n="/assets/stack_read.DlILjvGx.png",l="/assets/mem_layout.j40pLk91.png",h="/assets/copy_span.DPbJtu7p.png",o="/assets/switch_hax.D98jkp5C.jpg",E=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"fusee_gelee.md","filePath":"fusee_gelee.md"}'),p={name:"fusee_gelee.md"};function r(d,s,k,c,u,y){return a(),e("div",null,s[0]||(s[0]=[t(`<h2 id="vulnerability-disclosure-fusee-gelee" tabindex="-1"><strong>Vulnerability Disclosure: Fusée Gelée</strong> <a class="header-anchor" href="#vulnerability-disclosure-fusee-gelee" aria-label="Permalink to &quot;**Vulnerability Disclosure: Fusée Gelée**&quot;">​</a></h2><p>This report documents Fusée Gelée, a coldboot vulnerability that allows full, unauthenticated arbitrary code execution from an early bootROM context via Tegra Recovery Mode (RCM) on NVIDIA&#39;s Tegra line of embedded processors. As this vulnerability allows arbitrary code execution on the Boot and Power Management Processor (BPMP) before any lock-outs take effect, this vulnerability compromises the entire root-of-trust for each processor, and allows exfiltration of secrets e.g. burned into device fuses.</p><table tabindex="0"><thead><tr><th>Quick vitals:                    </th><th></th></tr></thead><tbody><tr><td><em>Reporter:</em></td><td>Katherine Temkin (@ktemkin)</td></tr><tr><td><em>Affiliation:</em></td><td>ReSwitched (<a href="https://reswitched.tech" target="_blank" rel="noreferrer">https://reswitched.tech</a>)</td></tr><tr><td><em>E-mail:</em></td><td><a href="mailto:k@ktemkin.com" target="_blank" rel="noreferrer">k@ktemkin.com</a></td></tr><tr><td><em>Affects:</em></td><td>Tegra SoCs, independent of software stack</td></tr><tr><td><em>Versions:</em></td><td>believed to affect Tegra SoCs released prior to the T186 / X2</td></tr><tr><td><em>Impact:</em></td><td>early bootROM code execution with no software requirements, which can lead to full compromise of on-device secrets where USB access is possible</td></tr><tr><td><em>Disclosure</em></td><td>public disclosure planned for June 15th, 2018</td></tr></tbody></table><h4 id="vulnerability-summary" tabindex="-1">Vulnerability Summary <a class="header-anchor" href="#vulnerability-summary" aria-label="Permalink to &quot;Vulnerability Summary&quot;">​</a></h4><p>The USB software stack provided inside the boot instruction rom (IROM/bootROM) contains a copy operation whose length can be controlled by an attacker. By carefully constructing a USB control request, an attacker can leverage this vulnerability to copy the contents of an attacker-controlled buffer over the active execution stack, gaining control of the Boot and Power Management processor (BPMP) before any lock-outs or privilege reductions occur. This execution can then be used to exfiltrate secrets and to load arbitrary code onto the main CPU Complex (CCPLEX) &quot;application processors&quot; at the highest possible level of privilege (typically as the TrustZone Secure Monitor at PL3/EL3).</p><hr><h4 id="public-disclosure-notice" tabindex="-1">Public Disclosure Notice <a class="header-anchor" href="#public-disclosure-notice" aria-label="Permalink to &quot;Public Disclosure Notice&quot;">​</a></h4><p>This vulnerability is notable due to the significant number and variety of devices affected, the severity of the issue, and the immutability of the relevant code on devices already delivered to end users. This vulnerability report is provided as a courtesy to help aid remediation efforts, guide communication, and minimize impact to users.</p><p>As other groups appear to have this or an equivalent exploit-- <a href="http://team-xecuter.com/team-xecuter-coming-to-your-nintendo-switch-console/" target="_blank" rel="noreferrer">including a group who claims they will be selling access to an implementation of such an exploit</a>-- it is the author and the ReSwitched team&#39;s belief that prompt public disclosure best serves the public interest. By minimizing the information asymmetry between the general public and exploit-holders and notifying the public, users will be able to best assess how this vulnerability impacts their personal threat models.</p><p>Accordingly, ReSwitched anticipates public disclosure of this vulnerability:</p><ul><li>If another group releases an implementation of the identified vulnerability; or</li><li>On June 15th, 2018, whichever comes first.</li></ul><hr><h3 id="vulnerability-details" tabindex="-1"><strong>Vulnerability Details</strong> <a class="header-anchor" href="#vulnerability-details" aria-label="Permalink to &quot;**Vulnerability Details**&quot;">​</a></h3><p>The core of the Tegra boot process is approximated by the following block of pseudo-code, as obtained by reverse-engineering an IROM extracted from a vulnerable T210 system:</p><div class="language-C vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">C</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// If this is a warmboot (from &quot;sleep&quot;), restore the saved state from RAM.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">read_scratch0_bit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  restore_warmboot_image</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">load_addr);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Otherwise, bootstrap the processor.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Allow recovery mode to be forced by a PMC scratch bit or physical straps.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  force_recovery </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> check_for_rcm_straps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> read_scratch0_bit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Determine whether to use USB2 or USB3 for RCM.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  determine_rcm_usb_version</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">usb_version);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  usb_ops </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> set_up_usb_ops</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(usb_version);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  usb_ops-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">initialize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // If we&#39;re not forcing recovery, attempt to load an image from boot media.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">force_recovery)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // If we succeeded, don&#39;t fall back into recovery mode.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">read_boot_configuration_and_images</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">load_addr) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SUCCESS) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      goto</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> boot_complete;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // In all other conditions</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">read_boot_images_via_usb_rcm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">snip</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">load_addr) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SUCCESS) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     /* load address is poisoned here */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">boot_complete:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* apply lock-outs, and boot the program at address load_address  */</span></span></code></pre></div><p>Tegra processors include a USB Recovery Mode (RCM), which we can observe to be activated under a number of conditions:</p><ul><li>If the processor fails to find a valid Boot Control Table (BCT) + bootloader on its boot media;</li><li>If processor straps are pulled to a particular value e.g. by holding a button combination; or</li><li>If the processor is rebooted after a particular value is written into a power management controller scratch register.</li></ul><p>USB recovery mode is present in all devices, including devices that have been production secured. To ensure that USB recovery mode does not allow unauthenticated communications, RCM requires all recovery commands be signed using either RSA or via AES-CMAC.</p><p>The bootloader&#39;s implementation of the Tegra RCM protocol is simple, and exists to allow loading a small piece of code (called the <em>miniloader</em> or <em>applet</em>) into the bootloader&#39;s local Instruction RAM (IRAM). In a typical application, this <em>applet</em> is <code>nvtboot-recovery</code>, a stub which allows further USB communications to bootstrap a system or to allow system provisioning.</p><p>The RCM process is approximated by the following pseudo-code, again obtained via reverse engineering a dumped IROM from a T210:</p><div class="language-C vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">C</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Significantly simplified for clarity, with error checking omitted where unimportant.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Repeatedly handle USB standard events on the control endpoint EP0.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  usb_ops-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">handle_control_requests</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(current_dma_buffer);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Try to send the device ID over the main USB data pipe until we succeed.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rcm_send_device_id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> USB_NOT_CONFIGURED ) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    usb_initialized </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Once we&#39;ve made a USB connection, accept RCM commands on EP1.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    usb_initialized </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Read a full RCM command and any associated payload into a global buffer.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // (Error checking omitted for brevity.)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    rcm_read_command_and_payload</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Validate the received RCM command; e.g. by checking for signatures</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // in RSA or AES_CMAC mode, or by trivially succeeding if we&#39;re not in</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // a secure mode.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rcm_validate_command</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (rc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> VALIDATION_PASS) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rc;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Handle the received and validated command.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // For a &quot;load miniloader&quot; command, this sanity checks the (validated)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // miniloader image and takes steps to prevent re-use of signed data not</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // intended to be used as an RCM command.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    rcm_handle_command_complete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(...);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>It is important to note that a full RCM command <em>and its associated payload</em> are read into 1) a global buffer, and 2) the target load address, respectively, before any signature checking is done. This effectively grants the attacker a narrow window in which they control a large region of unvalidated memory.</p><p>The largest vulnerability surface area occurs in the <code>rcm_read_command_and_payload</code> function, which accepts the RCM command and payload packets via a USB bulk endpoint. For our purposes, this endpoint is essentially a simple pipe for conveyance of blocks of binary data separate from standard USB communications.</p><p>The <code>rcm_read_command_and_payload</code> function actually contains several issues-- of which exactly one is known to be exploitable:</p><div class="language-C vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">C</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> total_rxd  </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> total_to_rx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">400</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Loop until we&#39;ve received our full command and payload.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (total_rxd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> total_to_rx) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Switch between two DMA buffers, so the USB is never DMA&#39;ing into the same</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // buffer that we&#39;re processing.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  active_buffer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> next_buffer;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  next_buffer   </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> switch_dma_buffers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Start a USB DMA transaction on the RCM bulk endpoint, which will hopefully</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // receive data from the host in the background as we copy.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  usb_ops-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">start_nonblocking_bulk_read</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(active_buffer, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // If we&#39;re in the first 680-bytes we&#39;re receiving, this is part of the RCM</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // command, and we should read it into the command buffer.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( total_rxd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 680</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* copy data from the DMA buffer into the RCM command buffer until we&#39;ve</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       read a full 680-byte RCM command */</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Once we&#39;ve received the first four bytes of the RCM command,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // use that to figure out how much data should be received.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( total_rxd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // validate:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      //  -- the command won&#39;t exceed our total RAM</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      //     (680 here, 0x30000 in upper IRAM)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      //  -- the command is &gt;= 0x400 bytes</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      //  -- the size ends in 8</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">rcm_command_buffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">302A8</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">u</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">              ||</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> rcm_command_buffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">400</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">u</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">              ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">rcm_command_buffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">F</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ERROR_INVALID_SIZE;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        left_to_rx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint32_t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)rcm_command_buffer);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* copy any data _past_ the command into a separate payload</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     buffer at 0x40010000 */</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* -code omitted for brevity - */</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Wait for the DMA transaction to complete.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // [This is, again, simplified to convey concepts.]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">usb_ops-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bulk_read_complete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // While we&#39;re blocking, it&#39;s still important that we respond to standard</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // USB packets on the control endpoint, so do that here.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    usb_ops-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">handle_control_requests</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(next_buffer);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Astute readers will notice an issue unrelated to the Fusée Gelée exploit: this code fails to properly ensure DMA buffers are being used exclusively for a single operation. This results in an interesting race condition in which a DMA buffer can be simultaneously used to handle a control request and a RCM bulk transfer. This can break the flow of RCM, but as both operations contain untrusted data, this issue poses no security risk.</p><p>To find the actual vulnerability, we must delve deeper, into the code that handles standard USB control requests. The core of this code is responsible for responding to USB control requests. A <em>control request</em> is initiated when the host sends a setup packet, of the following form:</p><table tabindex="0"><thead><tr><th>Field</th><th style="text-align:center;">        Size    </th><th>Description</th></tr></thead><tbody><tr><td>direction</td><td style="text-align:center;">1b</td><td>if &#39;1&#39;, the device should respond with data</td></tr><tr><td>type</td><td style="text-align:center;">2b</td><td>specifies whether this request is of a standard type or not</td></tr><tr><td>recipient</td><td style="text-align:center;">5b</td><td>encodes the context in which this request should be considered; <br> for example, is this about a <code>DEVICE</code> or about an <code>ENDPOINT</code>?</td></tr><tr><td>request</td><td style="text-align:center;">8b</td><td>specifies the request number</td></tr><tr><td>value</td><td style="text-align:center;">16b</td><td>argument to the request</td></tr><tr><td>index</td><td style="text-align:center;">16b</td><td>argument to the request</td></tr><tr><td>length</td><td style="text-align:center;">16b</td><td>specifies the maximum amount of data to be transferred</td></tr></tbody></table><p>As an example, the host can request the status of a device by issuing a <code>GET_STATUS</code> request, at which point the device would be expected to respond with a short setup packet. Of particular note is the <code>length</code> field of the request, which should <em>limit</em> -- but not exclusively determine-- the <em>maximum</em> amount of data that should be included in the response. Per the specification, the device should respond with either the <em>amount of data specified</em> or the <em>amount of data available</em>, whichever is less.</p><p>The bootloader&#39;s implementation of this behavior is conceptually implemented as follows:</p><div class="language-C vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">C</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Temporary, automatic variables, located on the stack.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint16_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> status;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data_to_tx;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// The amount of data available to transmit.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint16_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size_to_tx   </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // The amount of data the USB host requested.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint16_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> length_read  </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> setup_packet.length;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* Lots of handler cases have omitted for brevity. */</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Handle GET_STATUS requests.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (setup_packet.request </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> REQUEST_GET_STATUS)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // If this is asking for the DEVICE&#39;s status, respond accordingly.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(setup_packet.recipient </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RECIPIENT_DEVICE) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      status     </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> get_usb_device_status</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      size_to_tx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> sizeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(status);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Otherwise, respond with the ENDPOINT status.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (setup_packet.recipient </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RECIPIENT_ENDPOINT){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      status     </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> get_usb_endpoint_status</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(setup_packet.index);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      size_to_tx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> length_read;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // &lt;-- This is a critical error!</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* ... */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Send the status value, which we&#39;ll copy from the stack variable &#39;status&#39;.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  data_to_tx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">status;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Copy the data we have into our DMA buffer for transmission.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// For a GET_STATUS request, this copies data from the stack into our DMA buffer.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">memcpy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dma_buffer, data_to_tx, size_to_tx);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// If the host requested less data than we have, only send the amount requested.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// This effectively selects min(size_to_tx, length_read).</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (length_read </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size_to_tx) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  size_to_tx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> length_read;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Transmit the response we&#39;ve constructed back to the host.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">respond_to_control_request</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dma_buffer, length_to_send);</span></span></code></pre></div><p>In most cases, the handler correctly limits the length of the transmitted responses to the amount it has available, per the USB specification. However, in a few notable cases, the length is <em>incorrectly always set to the amount requested</em> by the host:</p><ul><li>When issuing a <code>GET_CONFIGURATION</code> request with a <code>DEVICE</code> recipient.</li><li>When issuing a <code>GET_INTERFACE</code> request with a <code>INTERFACE</code> recipient.</li><li>When issuing a <code>GET_STATUS</code> request with a <code>ENDPOINT</code> recipient.</li></ul><p>This is a critical security error, as the host can request up to 65,535 bytes per control request. In cases where this is loaded directly into <code>size_to_tx</code>, this value directly sets the extent of the <code>memcpy</code> that follows-- and thus can copy up to 65,535 bytes into the currently selected <code>dma_buffer</code>. As the DMA buffers used for the USB stack are each comparatively short, this can result in a <em>very</em> significant buffer overflow.</p><p>To validate that the vulnerability is present on a given device, one can try issuing an oversized request and watch as the device responds. Pictured below is the response generated when sending a oversized <code>GET_STATUS</code> control request with an <code>ENDPOINT</code> recipient to a T124:</p><p><img src="`+n+'" alt="Reading a chunk of stack memory from a K1"></p><p>A compliant device should generate a two-byte response to a <code>GET_STATUS</code> request-- but the affected Tegra responds with significantly longer response. This is a clear indication that we&#39;ve run into the vulnerability described above.</p><p>To really understand the impact of this vulnerability, it helps to understand the memory layout used by the bootROM. For our proof-of-concept, we&#39;ll consider the layout used by the T210 variant of the affected bootROM:</p><p><img src="'+l+'" alt="Bootrom memory layout"></p><p>The major memory regions relevant to this vulnerability are as follows:</p><ul><li>The bootROM&#39;s <em>execution stack</em> grows downward from <code>0x40010000</code>; so the execution stack is located in the memory <em>immediately preceding</em> that address.</li><li>The DMA buffers used for USB are located at <code>0x40005000</code> and <code>0x40009000</code>, respectively. Because the USB stack alternates between these two buffers once per USB transfer, the host effectively can control which DMA buffer is in use by sending USB transfers.</li><li>Once the bootloader&#39;s RCM code receives a 680-byte command, it begins to store received data in a section of upper IRAM located at address <code>0x40010000</code>, and can store up to <code>0x30000</code> bytes of payload. This address is notable, as it is immediately past the end of the active execution stack.</li></ul><p>Of particular note is the adjacency of the bootROM&#39;s <em>execution stack</em> and the attacker-controlled <em>RCM payload</em>. Consider the behavior of the previous pseudo-code segment on receipt of a <code>GET_STATUS</code> request to the <code>ENDPOINT</code> with an excessive length. The resulting memcpy:</p><ul><li>copies <em>up to</em> 65,535 bytes total;</li><li>sources data from a region <em>starting at the status variable on the stack</em> and extending significantly past the stack -- effectively copying mostly <em>from the attacker-controllable RCM payload buffer</em></li><li>targets a buffer starting either <code>0x40005000</code> or <code>0x40009000</code>, at the attacker&#39;s discretion, reaching addresses of up to <code>0x40014fff</code> or <code>0x40018fff</code></li></ul><p>This is a powerful copy primitive, as it copies <em>from attacker controlled memory</em> and into a region that <em>includes the entire execution stack</em>:</p><p><img src="'+h+'" alt="Effect of the vulnerability memcpy"></p><p>This would be a powerful exploit on any platform; but this is a particularly devastating attack in the bootROM environment, which does not:</p><ul><li>Use common attack mitigations such as stack canaries, ostensibly to reduce complexity and save limited IRAM and IROM space.</li><li>Apply memory protections, so the entire stack and all attacker controlled buffers can be read from, written to, and executed from.</li><li>Employ typical &#39;application-processor&#39; mitigation strategies such as ASLR.</li></ul><p>Accordingly, we now have:</p><ol><li>The capability to load arbitrary payloads into memory via RCM, as RCM only validates command signatures once payload receipt is complete.</li><li>The ability to copy attacker-controlled values over the execution stack, overwriting return addresses and redirecting execution to a location of our choice.</li></ol><p>Together, these two abilities give us a full arbitrary-code execution exploit at a critical point in the Tegra&#39;s start-up process. As control flow is hijacked before return from <code>read_boot_images_via_usb_rcm</code>, none of the &quot;lock-out&quot; operations that precede normal startup are executed. This means, for example, that the T210 fuses-- and the keydata stored within them-- are accessible from the attack payload, and the bootROM is not yet protected.</p><h4 id="exploit-execution" tabindex="-1">Exploit Execution <a class="header-anchor" href="#exploit-execution" aria-label="Permalink to &quot;Exploit Execution&quot;">​</a></h4><p>The Fusée Launcher PoC exploits the vulnerability described on the T210 via a careful sequence of interactions:</p><ol><li>The device is started in RCM mode. Device specifics will differ, but this is often via a key-combination held on startup.</li><li>A host computer is allowed to enumerate the RCM device normally.</li><li>The host reads the RCM device&#39;s ID by reading 16 bytes from the EP1 IN.</li><li>The host builds an exploit payload, which is comprised of: <ol><li>An RCM command that includes a maximum length, ensuring that we can send as much payload as possible without completing receipt of the RCM payload. Only the length of this command is used prior to validation; so we can submit an RCM command that starts with a maximum length of 0x30298, but which fills the remaining 676 bytes of the RCM command with any value.</li><li>A set of values with which to overwrite the stack. As stack return address locations vary across the series, it&#39;s recommended that a large block composed of a single entry-point address be repeated a significant number of times, so one can effectively replace the entire stack with that address.</li><li>The program to be executed (&quot;final payload&quot;) is appended, ensuring that its position in the binary matches the entry-point from the previous step.</li><li>The payload is padded to be evenly divisible by the 0x1000 block size to ensure the active block is not overwritten by the &quot;DMA dual-use&quot; bug described above.</li></ol></li><li>The exploit payload is sent to the device over EP1 OUT, tracking the number of 0x1000-byte &quot;blocks&quot; that have been sent to the device. If this number is <em>even</em>, the next write will be issued to the lower DMA buffer (<code>0x40005000</code>); otherwise, it will be issued to the upper DMA buffer (<code>0x40009000</code>).</li><li>If the next write would target the lower DMA buffer, issue another write of a full 0x1000 bytes to move the target to the upper DMA buffer, reducing the total amount of data to be copied.</li><li>Trigger the vulnerable memcpy by sending a <code>GET_STATUS</code> <code>IN</code> control request with an <code>ENDPOINT</code> recipient, and a length long enough to smash the desired stack region, and preferably not longer than required.</li></ol><p>A simple host program that triggers this vulnerability is included with this report: see <code>fusee-launcher.py</code>. Note the restrictions on its function in the following section.</p><hr><h3 id="proof-of-concept" tabindex="-1"><strong>Proof of Concept</strong> <a class="header-anchor" href="#proof-of-concept" aria-label="Permalink to &quot;**Proof of Concept**&quot;">​</a></h3><p>Included with this report is a set of three files:</p><ul><li><code>fusee-launcher.py</code> -- The main proof-of-concept accompanying this report. This python script is designed to launch a simple binary payload in the described bootROM context via the exploit.</li><li><code>intermezzo.bin</code> -- This small stub is designed to relocate a payload from a higher load address to the standard RCM load address of <code>0x40010000</code>. This allows standard RCM payloads (such as <code>nvtboot-recover.bin</code>) to be executed.</li><li><code>fusee.bin</code> -- An example payload for the Nintendo Switch, a representative and well-secured device based on a T210. This payload will print information from the device&#39;s fuses and protected IROM to the display, demonstrating that early bootROM execution has been achieved.</li></ul><p><strong>Support note:</strong> Many host-OS driver stacks are reluctant to issue unreasonably large control requests. Accordingly, the current proof-of-concept includes code designed to work in the following environments:</p><ul><li><strong>64-bit linux via <code>xhci_hcd</code></strong>. The proof-of-concept can manually submit large control requests, but does not work with the common <code>ehci_hcd</code> drivers due to driver limitations. A rough rule of thumb is that a connection via a blue / USB3 SuperSpeed port will almost always be handled by <code>xhci_hcd</code>.</li><li><strong>macOS</strong>. The exploit works out of the box with no surprises or restrictions on modern macOS.</li></ul><p>Windows support would require addition of a custom kernel module, and thus was beyond the scope of a simple proof-of-concept.</p><p>To use this proof-of-concept on a Nintendo Switch:</p><ol><li>Set up an Linux or macOS environment that meets the criteria above, and which has a working <code>python3</code> and <code>pyusb</code> as well as <code>libusb</code> installed.</li><li>Connect the Switch to your host PC with a USB A -&gt; USB C cable.</li><li>Boot the Switch in RCM mode. There are three ways to do this, but the first-- unseating its eMMC board-- is likely the most straightforward: <ol><li>Ensure the Switch cannot boot off its eMMC. The most straightforward way to to this is to open the back cover and remove the socketed eMMC board; corrupting the BCT or bootloader on the eMMC boot partition would also work.</li><li>Trigger the RCM straps. Hold VOL_UP and short pin 10 on the right JoyCon connector to ground while engaging the power button.</li><li>Set bit 2 of PMC scratch register zero. On modern firmwares, this requires EL3 or pre-sleep BPMP execution.</li></ol></li><li>Run the <code>fusee-launcher.py</code> with an argument of <code>fusee.bin</code>. (This requires <code>intermezzo.bin</code> to be located in the same folder as <code>fusee-launcher.py</code>.)</li></ol><pre><code>```\nsudo python3 ./fusee-launcher.py fusee.bin\n```\n</code></pre><p>If everything functions correctly, your Switch should be displaying a collection of fuse and protected-IROM information:</p><p><img src="'+o+'" alt="exploit working"></p><h3 id="recommended-mitigations" tabindex="-1"><strong>Recommended Mitigations</strong> <a class="header-anchor" href="#recommended-mitigations" aria-label="Permalink to &quot;**Recommended Mitigations**&quot;">​</a></h3><p>In this case, the recommended mitigation is to correct the USB control request handler such that it always correctly constrains the length to be transmitted. This has to be handled according to the type of device:</p><ul><li><strong>For a device already in consumer hands</strong>, no solution is proposed. Unfortunately, access to the fuses needed to configure the device&#39;s ipatches was blocked when the ODM_PRODUCTION fuse was burned, so no bootROM update is possible. It is suggested that consumers be made aware of the situation so they can move to other devices, where possible.</li><li><strong>For new devices</strong>, the correct solution is likely to introduce an new ipatch or new ipatches that limits the size of control request responses.</li></ul><p>It seems likely that OEMs producing T210-based devices may move to T214 solutions; it is the hope of the author that the T214&#39;s bootROM shares immunity with the T186. If not, patching the above is a recommended modification to the mask ROM and/or ipatches of the T214, as well.</p>',70)]))}const m=i(p,[["render",r]]);export{E as __pageData,m as default};
